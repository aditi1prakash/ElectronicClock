

/*
 * Filename: swc_clock.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 */

#include "project.h"
#include "global.h"
#include "rte.h"
#include "rte_types.h"
#include "swc_clock.h"

/* USER CODE START SWC_CLOCK_INCLUDE */
#include "sc_event_type.h"
#include "sc_clock_type.h"
#include "statemachine.h"
#include "tft.h"
/* USER CODE END SWC_CLOCK_INCLUDE */


#include "sp_common.h"

/* USER CODE START SWC_CLOCK_USERDEFINITIONS */
static uint8_t interruptFlag = 0;

#define HOURFORMAT_12_MAX          12
#define HOURFORMAT_24_MAX          24

#define MINUTES_MAX                60
/* USER CODE END SWC_CLOCK_USERDEFINITIONS */

/** --------------------------------------------- Actions ------------------------------------------------ **/

/**
 * Will dispatch KEYLEFT to Hours widget
 */
static void CLOCK__dispatch_KL_Hours();

/**
 * Will increment the clock after one minute
 */
static void CLOCK__increment1Minute();

/**
 * Will dispatch KEYLEFT to both Hours and Minutes widget
 */
static void CLOCK__dispatch_KL_HoursMin();

/**
 * Will dispatch KEYRIGHT to Hours widget
 */
static void CLOCK__dispatch_KR_Hours();

/**
 * Will dispatch KEYRIGHTLONGPRESS to Hours widget
 */
static void CLOCK__dispatch_KRLP_Hours();

/**
 * Will dispatch 250MS event to Hours widget
 */
static void CLOCK__dispatch_250MS_Hours();

/**
 * Will dispatch KEYLEFT to Minutes widget
 */
static void CLOCK__dispatch_KL_Min();

/**
 * Will dispatch KEYRIGHT to Minutes widget
 */
static void CLOCK__dispatch_KR_Min();

/**
 * Will dispatch KEYRIGHTLONGPRESS to Minutes widget
 */
static void CLOCK__dispatch_KRLP_Min();

/**
 * Will dispatch 250MS event to Minutes widget
 */
static void CLOCK__dispatch_250MS_Min();

/**
 * Sets the required display configuration for Edit mode of the clock
 */
static void CLOCK__setEditFonts();

/**
 * Increments the widget time in edit mode
 */
static void CLOCK__incrementWidget();

/**
 * Sets the required display configuration for Display mode of the clock
 */
static void CLOCK__setDisplayFonts();


/**
 * General Dispatcher, saving the states
 */
static void CLOCK__dispatch_wrapper(STATE_event_t ev, CLOCK_active_widget_t widget);

/** -------------------------------------- Container Transitions ------------------------------------------ **/

/** ==== IS_DISPLAYING ==== **/
static const STATE_stateInnerTransitionTable_t STATE_CLOCK_C_IS_DISPLAYING_Transitions = {
/*      Event                        ToState                        Guard              Action */
    { EVENT(EV_KEYLEFT),    STATE(STATE_CLOCK_C_ISEDITINGHOURS),       0,         CLOCK__dispatch_KL_Hours},
    { EVENT(EV_1MIN),       STATE(STATE_CLOCK_C_ISDISPLAYING),         0,         CLOCK__increment1Minute},
};

/** ==== IS_EDITINGHOURS ==== **/
static const STATE_stateInnerTransitionTable_t STATE_CLOCK_C_IS_EDITINGHOURS_Transitions = {
/*      Event                               ToState                            Guard              Action */
    { EVENT(EV_KEYLEFT),            STATE(STATE_CLOCK_C_ISEDITINGMINUTES),       0,          CLOCK__dispatch_KL_HoursMin},
    { EVENT(EV_KEYRIGHT),           STATE(STATE_CLOCK_C_ISEDITINGHOURS),         0,          CLOCK__dispatch_KR_Hours},
    { EVENT(EV_KEYRIGHTLONGPRESS),  STATE(STATE_CLOCK_C_ISEDITINGHOURS),         0,          CLOCK__dispatch_KRLP_Hours},
    { EVENT(EV_250MS),              STATE(STATE_CLOCK_C_ISEDITINGHOURS),         0,          CLOCK__dispatch_250MS_Hours},
};

/** ==== IS_EDITINGMINUTES ==== **/
static const STATE_stateInnerTransitionTable_t STATE_CLOCK_C_IS_EDITINGMINUTES_Transitions = {
/*      Event                               ToState                            Guard              Action */
    { EVENT(EV_KEYLEFT),            STATE(STATE_CLOCK_C_ISDISPLAYING),           0,          CLOCK__dispatch_KL_Min},
    { EVENT(EV_KEYRIGHT),           STATE(STATE_CLOCK_C_ISEDITINGMINUTES),       0,          CLOCK__dispatch_KR_Min},
    { EVENT(EV_KEYRIGHTLONGPRESS),  STATE(STATE_CLOCK_C_ISEDITINGMINUTES),       0,          CLOCK__dispatch_KRLP_Min},
    { EVENT(EV_250MS),              STATE(STATE_CLOCK_C_ISEDITINGMINUTES),       0,          CLOCK__dispatch_250MS_Min},
};    

const STATE_stateOuterTransitionTable_t CLOCK_Container_Transitions = {
/*           fromState                          Pointer to table                                    Size of table [Elements]        */
    { STATE(STATE_CLOCK_C_ISDISPLAYING),       &STATE_CLOCK_C_IS_DISPLAYING_Transitions,            sizeof(STATE_CLOCK_C_IS_DISPLAYING_Transitions)/sizeof(STATE_stateInnerTransition_t)},
    { STATE(STATE_CLOCK_C_ISEDITINGHOURS),     &STATE_CLOCK_C_IS_EDITINGHOURS_Transitions,          sizeof(STATE_CLOCK_C_IS_EDITINGHOURS_Transitions)/sizeof(STATE_stateInnerTransition_t)},
    { STATE(STATE_CLOCK_C_ISEDITINGMINUTES),   &STATE_CLOCK_C_IS_EDITINGMINUTES_Transitions,        sizeof(STATE_CLOCK_C_IS_EDITINGMINUTES_Transitions)/sizeof(STATE_stateInnerTransition_t)},
};

const uint16_t CLOCK_Container_Transitions_Size = sizeof(CLOCK_Container_Transitions)/sizeof(STATE_stateOuterTransition_t);

/** -------------------------------------- Widget Transitions ------------------------------------------ **/

/** ====== IS_DISPLAYING ========= **/
const STATE_stateInnerTransitionTable_t STATE_CLOCK_W_IS_DISPLAYING_Transitions = {
/*       Event                        ToState                     Guard           Action */
    { EVENT(EV_KEYLEFT),    STATE(STATE_CLOCK_W_ISEDITING),        0,      CLOCK__setEditFonts},
};

/** ===== IS_EDITING ====== **/
const STATE_stateInnerTransitionTable_t STATE_CLOCK_W_IS_EDITING_Transitions = {
/*          Event                        ToState                     Guard           Action */
    { EVENT(EV_KEYRIGHT),           STATE(STATE_CLOCK_W_ISEDITING),         0,      CLOCK__incrementWidget},
    { EVENT(EV_KEYRIGHTLONGPRESS),  STATE(STATE_CLOCK_W_ISAUTOINCREMENT),   0,      0},
    { EVENT(EV_KEYLEFT),            STATE(STATE_CLOCK_W_ISDISPLAYING),      0,      CLOCK__setDisplayFonts},
};

/** ===== IS_AUTOINCREMENT ====== **/
const STATE_stateInnerTransitionTable_t STATE_CLOCK_W_IS_AUTOINCREMENT_Transitions = {
/*          Event                        ToState                     Guard           Action */
    { EVENT(EV_KEYRIGHT),           STATE(STATE_CLOCK_W_ISEDITING),         0,      CLOCK__incrementWidget},
    { EVENT(EV_250MS),              STATE(STATE_CLOCK_W_ISAUTOINCREMENT),   0,      CLOCK__incrementWidget},
};

const STATE_stateOuterTransitionTable_t CLOCK_Widget_Transitions = {
/*           fromState                          Pointer to table                                Size of table [Elements]        */
    { STATE(STATE_CLOCK_W_ISDISPLAYING),       &STATE_CLOCK_W_IS_DISPLAYING_Transitions,        sizeof(STATE_CLOCK_W_IS_DISPLAYING_Transitions)/sizeof(STATE_stateInnerTransition_t)},
    { STATE(STATE_CLOCK_W_ISEDITING),          &STATE_CLOCK_W_IS_EDITING_Transitions,           sizeof(STATE_CLOCK_W_IS_EDITING_Transitions)/sizeof(STATE_stateInnerTransition_t)},
    { STATE(STATE_CLOCK_W_ISAUTOINCREMENT),    &STATE_CLOCK_W_IS_AUTOINCREMENT_Transitions,     sizeof(STATE_CLOCK_W_IS_AUTOINCREMENT_Transitions)/sizeof(STATE_stateInnerTransition_t)},
};

const uint16_t CLOCK_Widget_Transitions_Size = sizeof(CLOCK_Widget_Transitions)/sizeof(STATE_stateOuterTransition_t);


/*
* component: swc_clock
* cycletime: 50
* description: Runnable to process incoming events
* events: 
* name: CLOCK_input_run
* shortname: input
* signalIN: 
* signalOUT: so_event
* task: tsk_cyclic
*/
void CLOCK_input_run(RTE_event ev){
	
	/* USER CODE START CLOCK_input_run */
    static uint16_t runnableCount = 0;
    
    SC_EVENT_data_t eventSignal;
    
    // Increment the counter every time the runnable is scheduled (i.e., 50ms)
    runnableCount += 1;
    /** The current input runnable is being called every 50ms.
      * In order to set an event every 250ms, a local static
      * variable is used to count up to 5
      */
    if(runnableCount % 5 == 0)
    {
        eventSignal.m_ev = EV_250MS;
        //UART_LOG_PutString("Setting 250MS event\n");
        RTE_SC_EVENT_set (&SO_EVENT_signal, eventSignal);
    }
    
    /** To set EV_1MIN for every minute, the counter is incremented every 50ms.
      * 1200ms x 50ms = 60000ms = 60sec = 1min
      * The counter value is reset to zero after a minute to prevent overflow of the variable
      */
    if(runnableCount % 1200 == 0)
    {
        runnableCount = 0;
        eventSignal.m_ev = EV_1MIN;
        UART_LOG_PutString("Setting 1 minute event\n");
        RTE_SC_EVENT_set (&SO_EVENT_signal, eventSignal);
    }     
    
    //Check the long press of the button and set the event
    if((1 == interruptFlag) && (1 == Pin_ButtonRight_Read()))
    {
        static uint8_t countVar = 0;
        countVar += 1;
        //Runnable called every 50ms, 50 x 20 = 1000ms = 1s
        if(countVar % 20 == 0)
        {
            eventSignal.m_ev = EV_KEYRIGHTLONGPRESS;
            interruptFlag = 0;
            RTE_SC_EVENT_set (&SO_EVENT_signal, eventSignal);
        }
    }
    
    // Method 2 to check for long press of a button
//    if(interruptFlag == 4)
//    {
//        eventSignal.m_ev = EV_KEYRIGHTLONGPRESS;
//        interruptFlag = 0;
//        RTE_SC_EVENT_set (&SO_EVENT_signal, eventSignal);
//    }

    /* USER CODE END CLOCK_input_run */
}

/*
* component: swc_clock
* cycletime: 0
* description: Control runnable that runs the State Machine
* events: ev_event_onData
* name: CLOCK_control_run
* shortname: control
* signalIN: so_event
* signalOUT: so_clock
* task: tsk_event
*/
void CLOCK_control_run(RTE_event ev){
	
	/* USER CODE START CLOCK_control_run */
    UART_LOG_PutString("In control runnable\n");
    
    // Get the triggered event from the event component
    SC_EVENT_data_t eventSignal_t = RTE_SC_EVENT_get(&SO_EVENT_signal);
    
    //Get initial conditions required for the state machine
    SC_CLOCK_data_t clockData     = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    //Call the state machine
    RC_t result = STATE_processEvent(CLOCK_Container_Transitions, CLOCK_Container_Transitions_Size, 0, 0,
                                    eventSignal_t.m_ev, &clockData.m_containerState);
    
    UART_LOG_PutString("Completed State Machine processing\n");
    
    /** The values of SO_CLOCK_signal set by other functions was being 
      * overwritten when RTE_SC_CLOCK_set() API was called. This was causing
      * state machine to update incorrectly and the values of hour and minute
      * widgets were not being retained.
      * !! Dirty bug fix to avoid the issue !!
      */
    SO_CLOCK_signal.value.m_containerState = clockData.m_containerState;
    //RTE_SC_CLOCK_set(&SO_CLOCK_signal, clockData);

    /* USER CODE END CLOCK_control_run */
}

/*
* component: swc_clock
* cycletime: 250
* description: Runnable for display driver  
* events: 
* name: CLOCK_display_run
* shortname: display
* signalIN: so_clock
* signalOUT: so_display
* task: tsk_cyclic
*/
void CLOCK_display_run(RTE_event ev){
	
	/* USER CODE START CLOCK_display_run */
    
    //Get the clock signal data from clock component into a local variable
    SC_CLOCK_data_t clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    //Local variable to set the parameters of display component
    SC_DISPLAY_data_t dispTFT;

    //Extract the units and tens position from the clock value for minutes and hours
    dispTFT.minutes.unitValue = (clock.m_minutes.m_value % 10);
    dispTFT.minutes.tensValue = (clock.m_minutes.m_value / 10);
    
    dispTFT.hours.unitValue = (clock.m_hours.m_value % 10);
    dispTFT.hours.tensValue = (clock.m_hours.m_value / 10);
    
    //Set the values of display component and push them to the TFT driver
    RTE_SC_DISPLAY_set(&SO_DISPLAY_signal,dispTFT);
    RTE_SC_DISPLAY_pushPort(&SO_DISPLAY_signal);

    //UART_LOG_PutString("In display runnable\n");
    /* USER CODE END CLOCK_display_run */
}

/* USER CODE START SWC_CLOCK_FUNCTIONS */

static void CLOCK__dispatch_wrapper(STATE_event_t ev, CLOCK_active_widget_t widget)
{
    //Read the state object (container)
    SC_CLOCK_data_t clock = RTE_SC_CLOCK_get (&SO_CLOCK_signal);
    
    //Set the active widget to the hour widget
    clock.m_activeWidget = widget;
    
    //Write the changed widget back to the clock object
    RTE_SC_CLOCK_set (&SO_CLOCK_signal, clock);
    
    //And fire it to the container state machine
    //The widget state machine will be called by the container actions
    //We need a local copy of the widget state as the widget object is also changed by the widget actions
    if (CLOCK_HOURSWIDGET == widget)
    {
        UART_LOG_PutString("In dispatch function hours widget\n");
        CLOCK_state_t localState = clock.m_hours.m_widgetState;
        STATE_processEvent (CLOCK_Widget_Transitions, CLOCK_Widget_Transitions_Size, 0, 0, ev, &localState);
        
        //Re-read the state object in order to get the changes by the child
        clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
        clock.m_hours.m_widgetState = localState;
                
        //Write the changed state back to the clock object
        RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock);
    }
    else if (CLOCK_MINUTESWIDGET == widget)
    {
        UART_LOG_PutString("In dispatch function minutes widget\n");
        CLOCK_state_t localState = clock.m_minutes.m_widgetState;
        STATE_processEvent (CLOCK_Widget_Transitions, CLOCK_Widget_Transitions_Size, 0, 0, ev, &localState);
        
        //Re-read the state object in order to get the changes by the child
        clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
        clock.m_minutes.m_widgetState = localState;
        
        //Write the changed state back to the clock object
        RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock);
    }
}

static void CLOCK__dispatch_KL_Hours()
{
    UART_LOG_PutString("In CLOCK__dispatch_KL_Hours function\n");
    CLOCK__dispatch_wrapper(EV_KEYLEFT, CLOCK_HOURSWIDGET);
}

static void CLOCK__dispatch_KL_Min()
{
    UART_LOG_PutString("In CLOCK__dispatch_KL_Min function\n");
    CLOCK__dispatch_wrapper(EV_KEYLEFT, CLOCK_MINUTESWIDGET);
}

static void CLOCK__increment1Minute()
{
    UART_LOG_PutString("In increment 1 minute function\n");
    
    //Get a local copy of the clock component
    SC_CLOCK_data_t clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    //Check if the increment is less than the maximum value and then increment
    if (clock.m_minutes.m_value < MINUTES_MAX)
    {
        clock.m_minutes.m_value += 1;
    }
    //Set minutes to zero and increment hours when minute reaches maximum value
    else if(clock.m_minutes.m_value == MINUTES_MAX)
    {
        clock.m_minutes.m_value = 0;
        clock.m_hours.m_value += 1;
    }
    //When both reach the maximum value, reset the clock to zero
    else if((clock.m_minutes.m_value == MINUTES_MAX) && (clock.m_hours.m_value == HOURFORMAT_24_MAX))
    {
        clock.m_minutes.m_value = 0;
        clock.m_hours.m_value = 0;
    }
    else {/*do nothing*/}

    //Update the clock signal into signal object
    RTE_SC_CLOCK_set(&SO_CLOCK_signal, clock);
    
}

static void CLOCK__dispatch_KL_HoursMin()
{
    UART_LOG_PutString("In CLOCK__dispatch_KL_HoursMin function\n");
    CLOCK__dispatch_wrapper(EV_KEYLEFT, CLOCK_HOURSWIDGET);
    CLOCK__dispatch_wrapper(EV_KEYLEFT, CLOCK_MINUTESWIDGET);
}

static void CLOCK__dispatch_KR_Hours()
{
    UART_LOG_PutString("In CLOCK__dispatch_KR_Hours function\n");
    CLOCK__dispatch_wrapper(EV_KEYRIGHT, CLOCK_HOURSWIDGET);

}

static void CLOCK__dispatch_KRLP_Hours()
{
    UART_LOG_PutString("In CLOCK__dispatch_KRLP_Hours function\n");
    CLOCK__dispatch_wrapper(EV_KEYRIGHTLONGPRESS, CLOCK_HOURSWIDGET);
}

static void CLOCK__dispatch_250MS_Hours()
{
    UART_LOG_PutString("In CLOCK__dispatch_250MS_Hours function\n");
    CLOCK__dispatch_wrapper(EV_250MS, CLOCK_HOURSWIDGET);
}

static void CLOCK__dispatch_KR_Min()
{
    UART_LOG_PutString("In CLOCK__dispatch_KR_Min function\n");
    CLOCK__dispatch_wrapper(EV_KEYRIGHT, CLOCK_MINUTESWIDGET);
}

static void CLOCK__dispatch_KRLP_Min()
{
    UART_LOG_PutString("In CLOCK__dispatch_KRLP_Min function\n"); 
    CLOCK__dispatch_wrapper(EV_KEYRIGHTLONGPRESS, CLOCK_MINUTESWIDGET);
}

static void CLOCK__dispatch_250MS_Min()
{
    UART_LOG_PutString("In CLOCK__dispatch_250MS_Min function\n");
    CLOCK__dispatch_wrapper(EV_250MS, CLOCK_MINUTESWIDGET);
}

static void CLOCK__setEditFonts()
{
    UART_LOG_PutString("In CLOCK__setEditFonts function\n");
    
    //Get a local copy of the clock signal
    SC_CLOCK_data_t clock = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    //Check for the active widget and set it to edit mode, reset the other widget to display mode
    if(CLOCK_HOURSWIDGET == clock.m_activeWidget)
    {
        //Setting the hour widget to edit mode
        TFT_setCursor(TFT_HOUR_X_COORDINATE, TFT_WIDGET_Y_COORDINATE);
        TFT_fillRect(TFT_HOUR_X_COORDINATE, TFT_WIDGET_Y_COORDINATE, TFT_EDITMODE_WIDTH, TFT_EDITMODE_HEIGHT, WHITE);
        
        //Resetting the minute widget to display mode
        TFT_setCursor(TFT_MINUTE_X_COORDINATE, TFT_WIDGET_Y_COORDINATE);
        TFT_fillRect(TFT_MINUTE_X_COORDINATE, TFT_WIDGET_Y_COORDINATE, 36, 27, BLACK);
    }
    else if(CLOCK_MINUTESWIDGET == clock.m_activeWidget)
    {
        //Resetting the hour widget to display mode
        TFT_setCursor(TFT_HOUR_X_COORDINATE, TFT_WIDGET_Y_COORDINATE);
        TFT_fillRect(TFT_HOUR_X_COORDINATE, TFT_WIDGET_Y_COORDINATE, TFT_EDITMODE_WIDTH, TFT_EDITMODE_HEIGHT, BLACK);
        
        //Setting the minute widget to edit mode
        TFT_setCursor(TFT_MINUTE_X_COORDINATE, TFT_WIDGET_Y_COORDINATE);
        TFT_fillRect(TFT_MINUTE_X_COORDINATE, TFT_WIDGET_Y_COORDINATE, TFT_EDITMODE_WIDTH, TFT_EDITMODE_HEIGHT, WHITE);
    }
    else {/*do nothing*/}
}

static void CLOCK__incrementWidget()
{
    UART_LOG_PutString("In CLOCK__incrementWidget function\n"); 
    
    //Get local copy of clock signal
    SC_CLOCK_data_t clockData = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    //Check the active widget
    if(CLOCK_HOURSWIDGET == clockData.m_activeWidget)
    {
        //Increment by 1 when hour value less than max, else reset to zero
        if (clockData.m_hours.m_value < HOURFORMAT_24_MAX)
        {
            clockData.m_hours.m_value += 1;
            UART_LOG_PutString("Hour value: ");
            UART_LOG_PutChar(clockData.m_hours.m_value);
        }
        else
        {
            clockData.m_hours.m_value = 0;
        }
    }
    else if(CLOCK_MINUTESWIDGET == clockData.m_activeWidget)
    {
        //Increment by 1 when minute value less than maximum value, else reset to zero
        if (clockData.m_minutes.m_value < MINUTES_MAX)
        {
            clockData.m_minutes.m_value += 1;
            UART_LOG_PutString("Minute value: ");
            UART_LOG_PutChar(clockData.m_minutes.m_value);
        }
        else
        {
            clockData.m_minutes.m_value = 0;
        }
    }  
    
    //Set the clock signal object 
    RTE_SC_CLOCK_set(&SO_CLOCK_signal, clockData);  
}

static void CLOCK__setDisplayFonts()
{
    UART_LOG_PutString("In CLOCK__setDisplayFonts function\n"); 
    //Set hour widget to normal display mode
    TFT_setCursor(24, 73);
    TFT_fillRect(24, 73, 36, 27, BLACK);
    
    //Set minute widget to normal display mode
    TFT_setCursor(68, 73);
    TFT_fillRect(68, 73, 36, 27, BLACK);
    
}

/********************************************************************************
 * ISR Definitions
 ********************************************************************************/

ISR2(isr_button)
{
    //Local copy of event signal
    SC_EVENT_data_t eventSignal_t;
    
    if(1 == Pin_ButtonLeft_Read())          
    {
        eventSignal_t.m_ev = EV_KEYLEFT;
    }
    else if (1 == Pin_ButtonRight_Read())   
    {
        interruptFlag = 1;
        eventSignal_t.m_ev = EV_KEYRIGHT;
        //SetRelAlarm(alrm_250ms, 250, 250);
    }
    else    { /*do nothing*/ }
    
    //Set the event
    RTE_SC_EVENT_set(&SO_EVENT_signal, eventSignal_t);
}

/* USER CODE END SWC_CLOCK_FUNCTIONS */

